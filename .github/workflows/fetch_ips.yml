name: Fetch, Resolve, and Geolocate IPs/Domains

on:
  schedule:
    # 每3小时运行一次 (0, 3, 6, 9, 12, 15, 18, 21点 UTC)
    - cron: '0 */3 * * *'
  workflow_dispatch: # 允许手动触发

permissions:
  contents: write # 允许工作流写入仓库

jobs:
  fetch_and_process:
    runs-on: ubuntu-latest
    env:
      IPDATA_API_KEY: ${{ secrets.IPDATA_API_KEY }} # 从 GitHub Secrets 获取 API Key
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies (jq, dig)
        run: |
          sudo apt-get update
          sudo apt-get install -y jq dnsutils # dnsutils 包含 dig

      - name: Check for IPDATA_API_KEY
        run: |
          if [ -z "${IPDATA_API_KEY}" ]; then
            echo "Error: IPDATA_API_KEY secret is not set. Please add it to your repository secrets."
            exit 1
          fi
          echo "IPDATA_API_KEY found."

      - name: Fetch targets (IPs/Domains) from sources
        id: fetch_targets
        run: |
          echo "Fetching targets from source 1 (ymyuuu)..."
          curl -sSL "https://raw.githubusercontent.com/ymyuuu/IPDB/refs/heads/main/BestCF/bestcfv4.txt" > targets_source1.txt
          echo "Fetching targets from source 2 (ethgan)..."
          curl -sSL "https://raw.githubusercontent.com/ethgan/yxip/refs/heads/main/ip.txt" > targets_source2.txt
          echo "Fetching targets from source 3 (mefele)..."
          curl -sSL "https://raw.githubusercontent.com/mefele/test/refs/heads/main/1.txt" > targets_source3.txt
          
          echo "Combining and unique targets from 3 sources..."
          # cat所有源，然后sort -u去重，不过滤IP，因为现在也可能是域名
          cat targets_source1.txt targets_source2.txt targets_source3.txt | sed '/^\s*$/d' | sort -u > all_unique_targets.txt
          
          echo "Total unique targets found: $(wc -l < all_unique_targets.txt)"
          if [ ! -s all_unique_targets.txt ]; then
            echo "No targets found to process."
            echo "NO_TARGETS=true" >> $GITHUB_ENV
          else
            echo "NO_TARGETS=false" >> $GITHUB_ENV
          fi

      - name: Resolve domains and geolocate (using ipdata.co)
        if: env.NO_TARGETS == 'false' && env.IPDATA_API_KEY != ''
        run: |
          echo "Starting domain resolution and geolocation process with ipdata.co..."
          OUTPUT_FILE="geolocated_targets.txt"
          ERROR_LOG_FILE="geolocation_errors.txt"
          > "$OUTPUT_FILE" 
          > "$ERROR_LOG_FILE"

          # 函数：将国家代码映射到中文名称 (ipdata.co会提供英文名，这里做补充)
          get_chinese_country_name() {
            local code="$1"
            local english_name="$2" # 从ipdata.co获取的英文名
            case "$code" in
              "US") echo "美国";; "CA") echo "加拿大";; "CN") echo "中国";;
              "HK") echo "中国香港";; "TW") echo "中国台湾";; "JP") echo "日本";;
              "KR") echo "韩国";; "SG") echo "新加坡";; "GB") echo "英国";;
              "DE") echo "德国";; "FR") echo "法国";; "AU") echo "澳大利亚";;
              "NL") echo "荷兰";; "RU") echo "俄罗斯";; "IN") echo "印度";;
              "BR") echo "巴西";; "VN") echo "越南";; "MY") echo "马来西亚";;
              "TH") echo "泰国";; "ID") echo "印度尼西亚";;
              # 可以根据需要添加更多，或者如果ipdata.co的英文名足够好，就用英文名
              *) echo "$english_name";; # 如果没有匹配，返回ipdata.co提供的国家名
            esac
          }
          export -f get_chinese_country_name

          # 正则表达式判断是否为IP地址
          is_ip_address() {
            local target="$1"
            if [[ "$target" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
              return 0 # true
            else
              return 1 # false
            fi
          }

          while IFS= read -r target_line; do
            # 去除可能的CRLF行尾 (Windows换行符) 和前后空格
            target_line=$(echo "$target_line" | tr -d '\r' | xargs)
            if [ -z "$target_line" ]; then
              continue
            fi

            original_target="$target_line" # 保存原始输入行，用于最终输出
            ip_to_query=""

            if is_ip_address "$target_line"; then
              ip_to_query="$target_line"
              echo "Processing IP: $ip_to_query (from input: $original_target)"
            else
              echo "Processing Domain: $target_line, attempting to resolve..."
              # 使用 dig 获取A记录，只取第一个IP
              resolved_ip=$(dig +short A "$target_line" | head -n 1)
              if [ -z "$resolved_ip" ]; then
                echo "Error: Could not resolve domain $target_line" >> "$ERROR_LOG_FILE"
                echo "$original_target#DOMAIN_RESOLUTION_FAILED" >> "$OUTPUT_FILE"
                sleep 0.5 # 短暂延时
                continue
              else
                ip_to_query="$resolved_ip"
                echo "Domain $target_line resolved to IP: $ip_to_query"
              fi
            fi
            
            # 使用 ipdata.co 查询
            # fields参数选择我们需要的字段，减少数据传输和处理
            # language=zh-CN 尝试获取中文威胁信息，国家名通常默认是英文
            api_url="https://api.ipdata.co/${ip_to_query}?api-key=${IPDATA_API_KEY}&fields=ip,country_name,country_code"
            response=$(curl -sSL "$api_url")
            
            # 检查响应是否包含 "country_code" 来判断成功
            if echo "$response" | jq -e '.country_code' > /dev/null; then
              countryCode=$(echo "$response" | jq -r .country_code)
              countryNameEn=$(echo "$response" | jq -r .country_name) # ipdata.co 返回的英文国家名
              queryIp=$(echo "$response" | jq -r .ip) # API确认的IP

              if [ -z "$countryCode" ] || [ "$countryCode" = "null" ] || [ -z "$countryNameEn" ] || [ "$countryNameEn" = "null" ]; then
                echo "Warning: Geolocation data incomplete for IP $queryIp (from target $original_target). API Response: $response" >> "$ERROR_LOG_FILE"
                echo "$original_target#${queryIp}#UNKNOWN_GEO" >> "$OUTPUT_FILE"
              else
                # 获取自定义的中文国家名称
                chineseCountryName=$(get_chinese_country_name "$countryCode" "$countryNameEn")
                echo "$original_target#${countryCode}${chineseCountryName}" >> "$OUTPUT_FILE"
              fi
            else
              errorMessage=$(echo "$response" | jq -r '.message // "Unknown error or IP not found by ipdata.co"')
              echo "Error geolocating IP $ip_to_query (from target $original_target): $errorMessage. API Response: $response" >> "$ERROR_LOG_FILE"
              echo "$original_target#${ip_to_query}#ERROR_GEO" >> "$OUTPUT_FILE"
            fi
            
            # ipdata.co 免费版每月1500次请求，务必控制频率
            # 1500 / (30天 * 24小时/3小时的运行次数) = 1500 / (30*8) = 1500 / 240 ~= 6次请求/每次运行
            # 如果IP列表很长，这个延时需要非常大，或者升级ipdata.co套餐
            # 这里假设每次运行处理的IP不多，设置一个保守延时
            sleep 2 # 每次API调用后延时2秒
          done < all_unique_targets.txt

          echo "Geolocation process finished. Results in $OUTPUT_FILE"
          if [ -s "$ERROR_LOG_FILE" ]; then
            echo "Some errors occurred during geolocation. Check $ERROR_LOG_FILE for details."
          fi

      - name: Commit and push if changes
        if: env.NO_TARGETS == 'false' && env.IPDATA_API_KEY != ''
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          
          git add geolocated_targets.txt geolocation_errors.txt
          
          if git diff --staged --quiet; then
            echo "No changes to commit."
          else
            git commit -m "Update geolocated IP/Domain list (ipdata.co) ($(date -u +'%Y-%m-%d %H:%M:%S UTC'))"
            git push
            echo "Changes committed and pushed."
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
